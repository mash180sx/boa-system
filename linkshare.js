// Generated by CoffeeScript 1.3.1

/*
##  linkshare.coffee
##
##  TODO: 文字化け問題 : grep "�"
*/


(function() {
  var Category, Stream, category_id, concate, conf, db, dbinsert, fs, ftp, makeJSON, seed, split, txt, zlib;

  Stream = require('stream').Stream;

  zlib = require('zlib');

  fs = require('fs');

  ftp = require('./lib/ftp').ftp;

  conf = require('./config');

  db = require('./lib/db');

  /*
  ## split : line split stream
  */


  split = function(matcher) {
    var soFar, stream;
    stream = new Stream;
    soFar = '';
    if (!matcher) {
      matcher = '\n';
    }
    stream.writable = true;
    stream.readable = true;
    stream.write = function(buffer) {
      var pieces;
      pieces = (soFar + buffer).split(matcher);
      soFar = pieces.pop();
      pieces.forEach(function(piece) {
        return stream.emit('data', "" + piece);
      });
      return true;
    };
    stream.end = function() {
      if (soFar) {
        stream.emit('data', "" + soFar);
      }
      return stream.emit('end');
    };
    return stream;
  };

  /*
  ## makeJSON : make JSON stream
  */


  makeJSON = function() {
    var MID, index, name, stream, updateTime, _type;
    stream = new Stream;
    stream.writable = true;
    stream.readable = true;
    _type = ['', '中古', '新品', '大人買い'];
    MID = null;
    name = null;
    updateTime = null;
    index = 0;
    stream.write = function(buffer) {
      var buy, data, fixed, isbn10, isbn13, keywords, old, prices, release, sku, type, _data, _new, _ref, _ref1, _ref2, _ref3;
      data = buffer.split('|');
      if (data[0] === 'HDR') {
        MID = data[1];
        name = data[2].replace('【PC・携帯共通】', '');
        updateTime = new Date(data[3]);
        _data = {
          MID: MID,
          name: name,
          update: updateTime
        };
      } else if (data[0] === 'TRL') {
        _data = data[1];
        /*
              console.log('Trailer %d', data[1]);
              console.log('index = %d', in2);
              console.log('None category = %d', nonCategory);
              # console.log('];');
              console.log('Seed_categories = ', Category, ';');
        */

        stream.end();
      } else {
        keywords = data[18].split('~~');
        prices = keywords[0].split('/');
        fixed = ((_ref = prices[2]) != null ? _ref.indexOf(':') : void 0) > 0 ? Number(prices[2].split(':')[1]) : 0;
        _new = ((_ref1 = prices[1]) != null ? _ref1.indexOf(':') : void 0) > 0 ? Number(prices[1].split(':')[1]) : 0;
        old = ((_ref2 = prices[0]) != null ? _ref2.indexOf(':') : void 0) > 0 ? Number(prices[0].split(':')[1]) : 0;
        buy = ((_ref3 = prices[3]) != null ? _ref3.indexOf(':') : void 0) > 0 ? Number(prices[3].split(':')[1]) : 0;
        if (data[3] === '本・雑誌') {
          isbn13 = data[23];
          isbn10 = keywords[2];
        }
        type = _type[data[0].charAt(0)];
        sku = data[0].slice(1);
        release = new Date(data[14]);
        _data = {
          title: data[1],
          category: {
            primary: data[3],
            sub: data[4].split('~~')
          },
          url: {
            item: data[5],
            image: data[6]
          },
          type: type,
          author: data[8],
          sku: sku,
          JAN: data[23],
          price: {
            fixed: fixed,
            "new": _new,
            old: old,
            buy: buy
          },
          release: release,
          mount: 0,
          update: updateTime
        };
        switch (_data.category.primary) {
          case '本・雑誌':
            _data.isbn13 = isbn13;
            _data.isbn10 = isbn10;
        }
        stream.emit('data', _data);
      }
      return true;
    };
    stream.end = function() {
      return stream.emit('end');
    };
    return stream;
  };

  /*
  ##  concate stream : concate stream
  ##
  ##  concate chunk data to array
  */


  concate = function(unit) {
    var data, index, stream;
    if (unit == null) {
      unit = 100;
    }
    stream = new Stream;
    stream.writable = true;
    stream.readable = true;
    index = 0;
    data = [];
    stream.write = function(buffer) {
      data[index] = buffer;
      if ((++index % unit) === 0) {
        stream.emit('data', data);
        data = [];
      }
      return true;
    };
    stream.end = function() {
      if ((index % unit) > 0) {
        stream.emit('data', data);
        data = [];
      }
      return stream.emit('end');
    };
    return stream;
  };

  /*
  ##  db insert stream : pipable stream skelton
  ##  
  ##  insert array to db
  */


  dbinsert = function() {
    var stream;
    stream = new Stream;
    stream.writable = false;
    stream.readable = true;
    stream.write = function(buffer) {
      var data;
      data = buffer;
      stream.emit('data', buffer);
      return true;
    };
    stream.end = function() {
      return stream.emit('end');
    };
    return stream;
  };

  /*
  ## main :
  */


  seed = conf.seed;

  txt = seed.replace('.gz', '');

  Category = [];

  category_id = [];

  conf.db.clear = true;

  db.open(conf.db, function(err, client) {
    var Categories, Commodities, close, count, dones, hash, i, _Categories, _i, _len, _results;
    if (err) {
      throw err;
    }
    close = function(done) {
      if (done == null) {
        done = function() {};
      }
      done();
      return client.close();
    };
    Categories = client.collection('categories');
    Commodities = client.collection('commodities');
    if (conf.db.clear) {
      _Categories = ['本・雑誌', 'CD', 'DVD・ビデオ', 'ゲーム・おもちゃ'];
      count = 0;
      dones = [].map.call(_Categories, function(el) {
        return function() {
          return console.log(++count);
        };
      });
      console.log(dones);
      _results = [];
      for (i = _i = 0, _len = _Categories.length; _i < _len; i = ++_i) {
        hash = _Categories[i];
        (function(i) {
          var cb;
          return (cb = function(err, doc) {
            console.log(doc[0]);
            category_id[hash] = doc[0]._id;
            Category[hash] = 0;
            return console.log(i);
          })(i);
        });
        _results.push(Categories.insert({
          name: hash
        }, {
          safe: true
        }, cb));
      }
      return _results;
    } else {
      return close();
    }
  });

}).call(this);
