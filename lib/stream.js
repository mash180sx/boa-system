// Generated by CoffeeScript 1.3.3

/*
##  stream.coffee : pipable stream skelton
##
##  TODO: pause, resume or another unsupported
##        (to be referring the 'event-stream')
##
##  TODO: referctor all streams to class description
##
*/


(function() {
  var Stream;

  Stream = require('stream').Stream;

  exports.Stream = Stream;

  exports.stream = function() {
    var stream;
    stream = new Stream;
    stream.writable = true;
    stream.readable = true;
    stream.write = function(buffer) {
      var data;
      data = buffer;
      stream.emit('data', buffer);
      return true;
    };
    stream.end = function() {
      return stream.emit('end');
    };
    return stream;
  };

  /*
  ## split : line split stream
  */


  exports.split = function(matcher) {
    var soFar, stream, _in, _out;
    stream = new Stream;
    soFar = '';
    if (!matcher) {
      matcher = '\n';
    }
    stream.writable = true;
    stream.readable = true;
    _in = 0;
    _out = 0;
    stream.write = function(buffer) {
      var pieces;
      pieces = (soFar + buffer).split(matcher);
      soFar = pieces.pop();
      pieces.forEach(function(piece) {
        process.nextTick(function() {
          return stream.emit('data', piece);
        });
        return _out++;
      });
      _in++;
      return true;
    };
    stream.end = function() {
      if (soFar) {
        stream.emit('data', soFar);
        _out++;
      }
      process.nextTick(function() {
        return stream.emit('end');
      });
      return console.log("split end: in=" + _in + ", out=" + _out + " : " + (new Date));
    };
    return stream;
  };

  /*
  ##  concate stream : concate stream
  ##
  ##  concate chunk data to array
  */


  exports.concate = function(unit) {
    var data, index, stream, _in, _out;
    if (unit == null) {
      unit = 100;
    }
    stream = new Stream;
    stream.writable = true;
    stream.readable = true;
    index = 0;
    data = [];
    _in = 0;
    _out = 0;
    stream.write = function(buffer) {
      data[index % unit] = buffer;
      if ((++index % unit) === 0) {
        process.nextTick(function() {
          return stream.emit('data', data);
        });
        data = [];
        _out++;
      }
      _in++;
      return true;
    };
    stream.end = function() {
      if ((index % unit) > 0) {
        process.nextTick(function() {
          return stream.emit('data', data);
        });
        data = [];
        _out++;
      }
      process.nextTick(function() {
        return stream.emit('end');
      });
      return console.log("concate end: in=" + _in + ", out=" + _out + " : " + (new Date));
    };
    return stream;
  };

  /* TODO: should move db.coffee(unmake) these streams below !!!
  */


  /*
  ##  db insert stream : pipable stream skelton
  ##  
  ##  insert records to db
  */


  exports.dbinsert = function(collection, options) {
    var stream;
    if (options == null) {
      options = {};
    }
    options || (options = {
      safe: true
    });
    stream = new Stream;
    stream.writable = true;
    stream.readable = true;
    stream.inputLength = 0;
    stream.outputLength = 0;
    stream.write = function(buffer) {
      stream.inputLength++;
      return process.nextTick(function() {
        return collection.insert(buffer, options, function(err, doc) {
          stream.outputLength++;
          return true;
        });
      });
    };
    stream.end = function() {
      stream.writable = stream.readable = false;
      process.nextTick(function() {
        return stream.emit('end');
      });
      return console.log("dbinsert end: in=" + stream.inputLength + ", out=" + stream.outputLength + " : " + (new Date));
    };
    return stream;
  };

  /*
  ##  db update stream : pipable stream skelton
  ##  
  ##  update record to db
  */


  exports.dbupdate = function(collection, options, keys) {
    var stream;
    if (options == null) {
      options = {};
    }
    if (keys == null) {
      keys = ['_id'];
    }
    options.safe = true;
    stream = new Stream;
    stream.writable = true;
    stream.readable = true;
    stream.inputLength = 0;
    stream.outputLength = 0;
    stream.write = function(buffer) {
      var k, key, update, _i, _len;
      stream.inputLength++;
      key = {};
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        key[k] = buffer[k];
      }
      buffer.number = stream.inputLength;
      update = {
        $set: buffer
      };
      return process.nextTick(function() {
        return collection.update(key, update, options, function(err, doc) {
          stream.outputLength++;
          return true;
        });
      });
    };
    stream.end = function() {
      stream.writable = stream.readable = false;
      process.nextTick(function() {
        return stream.emit('end');
      });
      return console.log("dbupdate end: in=" + stream.inputLength + ", out=" + stream.outputLength + " : " + (new Date));
    };
    return stream;
  };

  /*
  ##  db find stream : pipable stream skelton
  ##  
  ##  db find
  */


  exports.dbfind = function(collection, query, field, options) {
    var stream;
    if (query == null) {
      query = {};
    }
    if (field == null) {
      field = {};
    }
    if (options == null) {
      options = {};
    }
    stream = collection.find(query, field).stream();
    stream.writable = true;
    stream.readable = true;
    stream.inputLength = 0;
    stream.outputLength = 0;
    stream.on('close', function() {
      return stream.emit('end');
    });
    return stream;
  };

  /*
  exports.dbfind = (collection, query={}, field={}, options={}) ->
    #console.log "options: #{JSON.stringify options}"
    #console.log "keys: #{keys}"
    
    stream = new Stream
    
    stream.writable = true
    stream.readable = true
    
    stream.inputLength = 0
    stream.outputLength = 0
    
    stream.cursor = collection.find(query, field)
    stream.cursor.each (err, doc)->
      if err
        stream.emit 'error', err
  
      if doc
        stream.inputLength++
        #console.log doc
        process.nextTick ->
          #stream.emit 'data', "#{JSON.stringify doc}\n"
          stream.emit 'data', doc
          stream.outputLength++
      else
        #console.log "doc is null"
        stream.emit 'end'
        console.log "dbfind end: in=#{stream.inputLength}, out=#{stream.outputLength} : #{new Date}"
  
    return stream
  */


}).call(this);
